<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《算法设计与分析》贪心法]]></title>
    <url>%2F2019%2F06%2F17%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B4.%20%E8%B4%AA%E5%BF%83%E6%B3%95%2F</url>
    <content type="text"><![CDATA[pdf文件]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法设计与分析》动态规划]]></title>
    <url>%2F2019%2F06%2F16%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B3.%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划算法总体思想？如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而提高计算效率。 基本步骤（重要） 找出最优解的性质，并刻划其结构特征。 递归地定义最优值。 以自底向上的方式计算出最优值。 根据计算最优值时得到的信息，构造最优解。 矩阵连乘问题有四个矩阵A，B，C，D，为了计算乘积ABCD，共有多少种不同的乘法顺序？ 若阶数分别为：A: 50*10，B: 10*40，C: 40*30，D: 30*5。哪种乘法顺序效率最高？ 答：5种。 序号 乘法顺序 乘法次数 1 (((AB)C)D) 87500 2 ((AB)(CD)) 36000 3 ((A(BC))D) 34500 4 (A((BC)D)) 16000 5 (A(B(CD))) 10500 矩阵连乘问题定义：给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1,2 ,…,n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。 一、找出最优解的性质，并刻划其结构特征。 特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。 若先不想动态规划，使用前面前面的分治法，可得递归定义式： 利用该递归定义式可以直接写出递归函数来计算m[i:j] static int recuMatrixChain (int i, int j){&nbsp;&nbsp;&nbsp;&nbsp;if (i == j) return 0;&nbsp;&nbsp;&nbsp;&nbsp;int u = recuMatrixChain (i+1,j) + p[i-1]p[i]p[j];&nbsp;&nbsp;&nbsp;&nbsp;for (int k = i+1; k &lt; j; k++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = recuMatrixChain (i,k) + recuMatrixChain (k+1,j) + p[i-1]p[k]p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t &lt; u) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return u;} 但是该算法的复杂度如何呢？ 递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次（子问题的重叠性质）。 二、递归地定义最优值。 设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] 当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n 当i&lt;j时，有m[i,j]=m[i,k]+m[k+1,j]+p_{i-1}p_{k}p_{j} 可以递归定义m[i,j]： 和上面是一样的。 三、以自底向上的方式计算出最优值。 public static void matrixChain(int [] p, int [][] m ){&nbsp;&nbsp;&nbsp;&nbsp;int n=p.length-1;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= n; i++) m[i][i] = 0;&nbsp;&nbsp;&nbsp;&nbsp;for (int r = 2; r &lt;= n; r++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= n - r+1; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j=i+r-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = i+1; k &lt; j; k++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t &lt; m[i][j]) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[i][j] = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 四、根据计算最优值时得到的信息，构造最优解。 public static void matrixChain(int [] p, int [][] m ){&nbsp;&nbsp;&nbsp;&nbsp;int n=p.length-1;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= n; i++) m[i][i] = 0;&nbsp;&nbsp;&nbsp;&nbsp;for (int r = 2; r &lt;= n; r++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt;= n - r+1; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j=i+r-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i][j] = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = i+1; k &lt; j; k++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t &lt; m[i][j]) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[i][j] = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i][j] = k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 动态规划算法的基本要素一、最优子结构矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。 在分析问题的最优子结构性质时，所用的方法具有普遍性：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾。 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。 注意：同一个问题可以有多种方式刻划它的最优子结构，有些表示方法的求解速度更快（空间占用小，问题的维度低） 二、重叠子问题递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。 动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。 通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。 三、备忘录方法备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。 m&lt;-0private static int lookupChain(int i, int j){&nbsp;&nbsp;&nbsp;&nbsp;if (m[i][j] &gt; 0) return m[i][j];&nbsp;&nbsp;&nbsp;&nbsp;if (i == j) return 0;&nbsp;&nbsp;&nbsp;&nbsp;else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int u = lookupChain(i+1,j) + p[i-1]*p[i]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i][j] = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int k = i+1; k &lt; j; k++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = lookupChain(i,k) + lookupChain(k+1,j) + p[i-1]*p[k]*p[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t &lt; u) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i][j] = k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[i][j] = u;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return u;&nbsp;&nbsp;&nbsp;&nbsp;}} 最长单调递增子序列设计一个O(n^2)时间的算法，找出由n个数组成的序列的最长单调递增子序列。 设序列为a[0:n-1]，记b[i]：以a[i]为结尾元素的最长递增子序列的长度。 则序列a的最长递增子序列长度为 如何求b[i]？ 最长公共子序列 给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找出X和Y的最长公共子序列。 设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则 1)若xm=yn， 则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列。 2)若xm≠yn， 则Z是 Xm-1和Y的最长公共子序列，X和Yn-1的最长公共子序列， 中较长的序列。 子问题的递归结构由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i][j]记录序列的最长公共子序列的长度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时c[i][j]=0。其他情况下，由最优子结构性质可建立递归关系如下： 计算最优值、最优解 凸多边形最优三角剖分表示具有n条边的凸多边形:用多边形顶点的逆时针序列表示凸多边形，即P={v0,v1,…,vn-1}。 若vi与vj是多边形上不相邻的2个顶点，则线段vivj称为多边形的一条弦。弦将多边形分割成2个多边形{vi,vi+1,…,vj}和{vj,vj+1,…vi}。 多边形的三角剖分是将多边形分割成互不相交的三角形的弦的集合T。 给定凸多边形P，以及定义在由多边形的边和弦组成的三角形上的权函数w。要求确定该凸多边形的三角剖分，使得即该三角剖分中诸三角形上权之和为最小。 最优子结构性质事实上，若凸(n+1)边形P=\{v_{0},v_{1},…,v_{n-1},v_{n}\}的最优三角剖分T包含三角形v_{0}v_{k}v_{n}，1≤k≤n-1，则T的权为3个部分权的和：三角形v_{0}v_{k}v_{n}的权，子多边形\{v_{0},v_{1},…,v_{k}\}和\{v_{k},v_{k+1},…,v_{n}\}的权之和。可以断言，由T所确定的这2个子多边形的三角剖分也是最优的。 因为若有\{v_{0},v_{1},…,v_{k}\}或\{v_{k},v_{k+1},…,v_{n}\}的更小权的三角剖分将导致T不是最优三角剖分的矛盾。 多边形游戏问题多边形游戏是一个单人玩的游戏，开始时有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符“+”或“*”。所有边依次用整数从1到n编号。 游戏第1步，将一条边删除。 随后n-1步按以下方式操作： (1)选择一条边E以及由E连接着的2个顶点V1和V2； (2)用一个新的顶点取代边E以及由E连接着的2个顶点V1和V2。将由顶点V1和V2的整数值通过边E上的运算得到的结果赋予新顶点。 最后，所有边都被删除，游戏结束。游戏的得分就是所剩顶点上的整数值。 问题：对于给定的多边形，计算最高得分。 图像压缩电路布线流水作业调度0-1背包问题最优二叉搜索树]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[软件测试 date: 2019-06-15 13:59:00 常见的接口测试类型？ HTTP（get、post）、WebService（get、post）（wsdl）、socket（少见） 工具的选用 Jmeter（基于Java实现的） Firefox的插件httprequester 在线工具 http://www.atool.arg/httptest.php postman（一个插件） soapui loadrunner 例子 http类型的接口测试，老黄历接口：https://v.juhe.cn/laohuangli/d data={“key”:”sdsfasdafdsafsafdsa”,data:”2019-03-23”} 聚合数据网站还有其它接口 app界面元素 各种栏（状态栏、导航栏、标签栏、工具栏） 内容视图（列表、卡片、集合视图、图片、文本） 控制元素（页面控制器、分段式控件、滑动开关、选择器、文本框、按钮、进度条、刷新视图、调节器） 临时视图（警示视图、操作列表、模态视图、toast）]]></content>
  </entry>
  <entry>
    <title><![CDATA[《算法设计与分析》习题]]></title>
    <url>%2F2019%2F06%2F15%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一章1-1 说明下面的方法swap为什么无法交换实际参数的值？123456public static void swap(int x,int y) &#123; int temp=x; x=y; y=temp;&#125; 方法参数传的是值（基本数据类型），不是引用，方法调用结束后，参数x、y出栈。 1-2 说明下面的两个方法头是否有不同的签名，为什么？(1) public int fff(int i,int j,int k)(2) public float fff(int i,int j,int k) 相同，只要方法名和参数列表相同，他们的方法签名就相同，他们都是fff+int i,int j,int k。 1-4 求下列函数的渐进表达式。(1) 3n^2+10n\\(2) n^2/10+2^n\\(3) 21+1/n\\(4 )logn^3\\(5) 10log3^nO(n^2)\\O(2^2)\\O(1)\\O(logn)\\O(n)\\ 1-5 说明0(1)和O(2)的区别。O(1)和O(2)差别仅在于其中的常数因子,根据渐进上界记号O的定义可知,O(1)=O(2)。 1-6 按照渐进阶从低到高的顺序排列以下表达式：$4n^2, logn, 3^n,20n,2,n^{2/3}$。又n!应该排在哪一位？2]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计课程复习]]></title>
    <url>%2F2019%2F06%2F14%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B2.%20%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法计算阶乘n!设计递归函数，计算n!的值，其中n&gt;0。 1234int factorial(int n)&#123; if(n==1) return 1; else return factorial(n-1)*n;&#125; Fibonacci数列F_n=F_{n-1}+F_{n-2},F_1=F_2=1Hanoi塔假定n-1个盘子的转移算法已确定，对n个圆盘的问题： ​ 第1步：把A上面的n-1个圆盘经C转移到B上 ​ 第2步：把A最下面的一个圆盘移到C上 ​ 第3步：把B上的n-1圆盘经A转移到C上 转移完毕。 算法分析：令h(n)表示n个圆盘所需要的转移盘次，则算法复杂度为？ h(n) = 2h(n-1) + 1, h(1)=1h(n) = 2^n -1分治算法总体思想 将求解的较大规模的问题分割成k个更小规模的子问题。对这k个子问题分别求解。 比如上面的factorial函数，将n规模的任务缩小为n-1规模的任务。任务规模不一定缩小为n-1，也可能是n/2（如：折半查找）等等。 如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。 分治法的设计思想​ 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。凡治众如治寡，分数是也。—-孙子兵法 分治法的适用条件分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。 分治法的基本步骤(重要)divide-and-conquer(P){&nbsp;&nbsp;&nbsp;&nbsp;if ( | P | &lt;= n0) adhoc(P); //解决小规模的问题&nbsp;&nbsp;&nbsp;&nbsp;divide P into smaller subinstances P1,P2,…,Pk；//分解问题&nbsp;&nbsp;&nbsp;&nbsp;for (i=1,i&lt;=k,i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yi=divide-and-conquer(Pi); //递归的解各子问题&nbsp;&nbsp;&nbsp;&nbsp;return merge(y1,…,yk); //将各子问题的解合并为原问题的解} 分治法的复杂性分析(重要)一个分治法将规模为n的问题分成k个规模为n/m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： 通过迭代法求得方程的解（记住n^{\log_{m}k}，以后分析算法复杂度的时候会用到）： 二分查找给定已按升序排好序的n个元素，现要在这n个元素中找出一特定元素。 递归写法： int BinarySearch (int x, int a[], intlow int high ){&nbsp;&nbsp;&nbsp;&nbsp;//递归实现二分查找算法，找不到返回-1&nbsp;&nbsp;&nbsp;&nbsp;if ( low &gt; high) return -1;&nbsp;&nbsp;&nbsp;&nbsp;mid = (low+high)/2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x==a[mid]) return mid;&nbsp;&nbsp;&nbsp;&nbsp;if (x&gt;a[mid]) return BinarySearch(x, a, mid+1, high);&nbsp;&nbsp;&nbsp;&nbsp;else return BinarySearch(x, a, low, mid-1);} 非递归写法： int Search_Bin ( SSTable ST, KeyType kval ) {&nbsp;&nbsp;&nbsp;&nbsp;low = 1; high = ST.length; // 置区间初值&nbsp;&nbsp;&nbsp;&nbsp;while (low &lt;= high) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid = (low + high) / 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( kval == ST.elem[mid].key )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mid; // 找到待查元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ( kval &lt; ST.elem[mid].key) )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high = mid - 1; // 继续在前半区间进行查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else low = mid + 1; // 继续在后半区间进行查找&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return -1;} 快速排序快速排序是对气泡排序的一种改进方法。它是由C.A.R. Hoare于1962年提出的。 基本思想是任取待排序对象序列中的某个对象 (例如取第一个对象) 作为基准, 按照该对象的排序码大小,将整个对象序列划分为左右两个子序列：左序列 ≤ 基准对象 ≤ 右序列 在快速排序中，记录的比较和交换是从两端向中间进行的，关键字较大的记录一次就能交换到后面单元，关键字较小的记录一次就能交换到前面单元，记录每次移动的距离较大，因而总的比较和移动次数较少。 private static void qSort(int p, int r){&nbsp;&nbsp;&nbsp;&nbsp;if (p&lt;r) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int q=partition(p,r); //划分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSort (p,q-1); //对左半段排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSort (q+1,r); //对右半段排序&nbsp;&nbsp;&nbsp;&nbsp;}} private static int partition (int p, int r){&nbsp;&nbsp;&nbsp;&nbsp;int i = p,&nbsp;&nbsp;&nbsp;&nbsp;j = r + 1;&nbsp;&nbsp;&nbsp;&nbsp;Comparable x = a[p];&nbsp;&nbsp;&nbsp;&nbsp;// 将&gt;= x的元素交换到左边区域&nbsp;&nbsp;&nbsp;&nbsp;// 将&lt;= x的元素交换到右边区域&nbsp;&nbsp;&nbsp;&nbsp;while (true) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (a[++i].compareTo(x) &lt; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (a[—j].compareTo(x) &gt; 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i &gt;= j) break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyMath.swap(a, i, j);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;a[p] = a[j];&nbsp;&nbsp;&nbsp;&nbsp;a[j] = x;&nbsp;&nbsp;&nbsp;&nbsp;return j;} ​ 快速排序算法的性能取决于划分的对称性。通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。在快速排序算法的每一步中，当数组还没有被划分时，可以在a[p:r]中随机选出一个元素作为划分基准，这样可以使划分基准的选择是随机的，从而可以期望划分是较对称的。 private static int randomizedPartition (int p, int r){ int i = random(p,r); MyMath.swap(a, i, p); return partition (p, r);} 最坏时间复杂度：O(n^2)平均时间复杂度：O(nlogn)辅助空间：O(n)或O(logn)稳定性：不稳定 合并排序算法mergeSort的过程。 基本思想：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。 public static void mergeSort(Comparable a[], int left, int right){&nbsp;&nbsp;&nbsp;&nbsp;if (left&lt;right) {//至少有2个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i=(left+right)/2; //取中点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(a, left, i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(a, i+1, right);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge(a, b, left, i, right); //合并到数组b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy(a, b, left, right); //复制回数组a&nbsp;&nbsp;&nbsp;&nbsp;}} 复杂度分析： T(n) = \left \{ \begin{matrix} O(1) & n1\end{matrix} \right.T(n)=O(logn)渐进意义下的最优算法。 最坏时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)辅助空间：O(n)稳定性：稳定 大整数的乘法 请设计一个有效的算法，可以进行两个n位大整数的乘法运算。 tip：算法分析，更多追求的是算法设计思想，别太深究代码中的错误。你如果硬要深究，我就说这是伪代码，哼(￢︿̫̿￢☆) X = a 2^{n/2}+bY = c 2^{n/2}+dXY = ac 2^n + (ad+bc) 2^{n/2} + bd XY = ac2^n + ((a-b)(d-c)+ac+bd)2^{n/2}+bd或 XY = ac 2^n + ((a+c)(b+d)-ac-bd) 2^{n/2} + bd 细节问题：两个XY的复杂度都是O(nlog3)，但考虑到a+c,b+d可能得到m+1位的结果，使问题的规模变大，故不选择第2种方案。 更快的方法??如果将大整数分成更多段，用更复杂的方式把它们组合起来，将有可能得到更优的算法。 最终的，这个思想导致了快速傅利叶变换(Fast Fourier Transform)的产生。该方法也可以看作是一个复杂的分治算法，对于大整数乘法，它能在O(nlogn)时间内解决。 是否能找到线性时间的算法？目前为止还没有结果。 Strassen矩阵乘法传统方法：O(n^3)分治法: 使用与上例类似的技术，将矩阵A，B和C中每一矩阵都分块成4个大小相等的子矩阵。由此可将方程C=AB重写为： \begin{bmatrix}C_{11} &C_{12} \\\\ C_{21} & C_{22} \end{bmatrix} = \begin{bmatrix}A_{11} &A_{12} \\\\ A_{21} & A_{22} \end{bmatrix}\begin{bmatrix}B_{11} &B_{12} \\\\ B_{21} & B_{22} \end{bmatrix}由此可得： C_{11}= A_{11}B_{11}+A_{12}B_{21}\\\\C_{12}=A_{11}B_{12}+A_{12}B_{22}\\\\C_{21}=A_{21}B_{11}+A_{22}B_{21}\\\\C_{22}=A_{21}B_{12}+A_{22}B_{22} 为了降低时间复杂度，必须减少乘法的次数。 更快的方法??Hopcroft和Kerr已经证明(1971)，计算2个２×２矩阵的乘积，7次乘法是必要的。因此，要想进一步改进矩阵乘法的时间复杂性，就不能再基于计算2×2矩阵的7次乘法的方法了。 或许应当研究３×３或５×５矩阵的更好算法。在Strassen之后又有许多算法改进了矩阵乘法的计算时间复杂性。目前最好的计算时间上界是 O(n^{2.376}) 是否能找到$O(n^2)$的算法？目前为止还没有结果。 思考题给定a，设计出求a^n的算法。 设计算法，找出数组a[n]的中位数。 设计算法，找出数组a[n]中序为k的数。 设计算法，输出数组a[n]中所有序为奇数的数。 设计算法，计算序列a[n]中的逆序数。 假设a[0:m]，a[m:n]均升序，设计算法，计算序列a[n]中的逆序数。 查找数组a[n]中的最大元素，至少需要多少次比较? 查找数组a[n]中的最大和最小元素，用最少的元素比较次数。 查找数组a[n]中的第k小的元素（k相对于n比较小)； 查找数组a[n]中的中位数（序号为n/2)； 查找数组a[n]中的最大元素，至少需要多少次比较? 查找数组a[n]中的最大和最小元素，用最少的元素比较次数。 查找数组a[n]中的第k小的元素（k相对于n比较小)； 查找数组a[n]中的中位数（序号为n/2)； 给定有序表A[1:n]，修改合并排序算法，求出该有序表的逆序对数。 参考汕头大学算法分析设计课程PPT__老师（CHYD） 补充人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种平衡(balancing)子问题的思想，它几乎总是比子问题规模不等的做法要好。]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法设计与分析》引论]]></title>
    <url>%2F2019%2F06%2F14%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B1.%20%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[第一章程序 = ？数据结构+算法 算法的四个特性？输入、输出、有穷、确定 好的算法？正确性、可读性、健壮性、高效率和低存储量需求 算法复杂度排序？复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O($n^{2}$)、立方阶O($n^{3}$)、…、k次方阶O($n^{k}$)、指数阶O($2^{n}$)、阶乘阶($n!$)。 算法复杂度分析中的四个符号是？分别代表什么？ Ω O θ o ≥ 渐渐下界 ≤ 渐进上界 ＝ ＜ 练习题设n是描述问题规模的非负整数，下面程序片段的时间复杂度是？ 123x=2;while(x&lt;n) x = x+2; A．O(log_{2}n) B．O(n)C．O(nlog_{2}n) D．O(n^{2}) 设n是描述问题规模的非负整数，下面程序片段的时间复杂度是？ 123x=2;while(x&lt;n/2) x = 2*x; 答：O(log_{2}n) 解析： 在程序中， 执行频率最高的语句为”x = 2*x “。设该语句共执行了T (n)次，则2^{T(n)+1}]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo杂记]]></title>
    <url>%2F2019%2F06%2F13%2Fhexo%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建新文章(post)？1$ hexo new "My New Post" 开启本地服务器？1$ hexo server 生成静态文件？1$ hexo generate 部署到远程网站？1$ hexo deploy 必须注意，在hexo d的时候，不是把所有文件上传一遍，它会检查本地部署日志文件，然后再根据修改情况进行相应地部署。 所以，如果你在其它地方更新了远程仓库的某个文件，本地没有进行更新，你调试的时候可能会出错，你还奇了怪了。 记住：以本地仓库为主，别在远程更新文件！ hexo网页中出现阿拉伯文？设置语言时出现了问题，把zh_cn改成zh-CN试试。 给文章添加标签？把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 给文章分类？把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： 12title: 分类测试文章标题categories: 分类名 设置侧边栏（sidebar）？打开主题配置文件找到sidebar字段。 头像设置？打开主题配置文件找到Sidebar Avatar字段（侧边栏阿凡达）。 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 在主页不想要展示一个文章所有内容，添加阅读全文按钮？如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看。 文章基本设置：123456789101112---title: CentOS7下Tomcat启动慢的原因及解决方案date: 2017-12-02 21:01:24comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;云服务器&quot; #分类 - 分类1 - 分类2tags: #标签 - 标签1 - 标签2--- 图片？写文章时，hexo的图片文件都放在了与md文件同名的文件夹下（md文件和文件夹是分离的）。 然而，生成public静态文件时，图片文件却与index.html文件在同一个文件夹。 在md文件中采用相对路径引用图片，生成的html也会采用相对路径来引用图片，但此时图片和html是在同一个文件夹啊！所以页面当然不能正常显示图片了。 解决方法：到这个仓库去，https://github.com/xcodebuild/hexo-asset-image.git 安装该插件以后，还得到\node_modules\hexo-asset-image去改index.js脚本文件。因为它的有错误！ 比如我发现这么个错误： 12// var endPos = link.lastIndexOf('.'); //获取最后一个点的位置，不就是.io吗？也说不定啊，文件名可以允许有点啊。比如xxx.xxx.jpg，这里显得不严谨！所以后面切子串的时候错了！var endPos = getPosition(link, '/', 7); 改完这个后，再在typora设置： 现在我可以在typora上可视化的插入图片进行编写md文件了。 不用写那么麻烦的官方标签了，比如： 1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 这样的标签在typora上无法渲染，在GitHub上也无法渲染，因为它是hexo独有的，不推荐。 卸载该插件： 1npm uninstall hexo-asset-image 安装该插件： 1npm install hexo-asset-image --save latex数学公式？注意，使用latex公式时，要用两个$$符号，不是一个，不然在网页端解析会出现问题。 以两个美元符号开始一行的话，可能会被忽略掉！如下： 1$$64n^&#123;2&#125; = n1^&#123;2&#125;$$，解得n1=8n。 md文件中敲再多连续的空格，到了网页上都只会显示一个空格。于是就想着将md文件中的连续的四个空格替换为： 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 怎么实现呢？用nodejs 替换文件中所有图片的url 参考上面的文章。把它写好后，在hexo g开始后，马上替换掉md文件中符合要求的内容，这样就不用每次都选中，然后ctrl+h进行替换了。 思路有了，但目前还没去做，现在我只是在notepad++中进行CTRL+H。 除了空格需要替换，数学表达式中的星号*也需要转义，因为md文件中星号可能被用于加粗字体。 貌似左括号“[”右括号“]”也需要转义。 Hexo 如何引入自定义 js 文件 Hexo 中静态文件放在主题文件夹中，即 1your_project/themes/&lt;theme_name&gt;/source 在这个文件夹中会有 js, css, img 等文件夹，没有的话可以自己创建，将自定义的 js 放到其中，在 markdown 文章中直接引用即可。 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/test.js&quot;&gt;&lt;/script&gt; 可以不用在markdown文章中引用，在 1\themes\next\layout\_layout.swig 中引用也可以。 主题目录下的source文件夹中的文件部署的时候，会直接放到仓库中。 下载pdf.js稳定版，解压后放在主题目录下的source文件夹中，部署， 输入： https://chiuinmeng.github.io/pdf.js/web/viewer.html 就可查看pdf。 https://chiuinmeng.github.io/pdf.js/web/viewer.html?file=https://chiuinmeng.github.io/2019/06/17/%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B4.%20%E8%B4%AA%E5%BF%83%E6%B3%95/%E8%B4%AA%E5%BF%83%E6%B3%95.pdf 便可查看其它pdf hexo中应该放pdf吗？ 不推荐！！！pdf是二进制文件，不是文本文件，所以对于搜索引擎不友好，无法直接搜索pdf中的文字信息。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
