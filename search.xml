<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《算法设计与分析》习题]]></title>
    <url>%2F2019%2F06%2F15%2F%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一章1-1 说明下面的方法swap为什么无法交换实际参数的值？123456public static void swap(int x,int y) &#123; int temp=x; x=y; y=temp;&#125; 方法参数传的是值（基本数据类型），不是引用，方法调用结束后，参数x、y出栈。 1-2 说明下面的两个方法头是否有不同的签名，为什么？(1) public int fff(int i,int j,int k)(2) public float fff(int i,int j,int k) 相同，只要方法名和参数列表相同，他们的方法签名就相同，他们都是fff+int i,int j,int k。 1-4 求下列函数的渐进表达式。(1) 3n^2+10n\\(2) n^2/10+2^n\\(3) 21+1/n\\(4 )logn^3\\(5) 10log3^nO(n^2)\\O(2^2)\\O(1)\\O(logn)\\O(n)\\ 1-5 说明0(1)和O(2)的区别。O(1)和O(2)差别仅在于其中的常数因子,根据渐进上界记号O的定义可知,O(1)=O(2)。 1-6 按照渐进阶从低到高的顺序排列以下表达式：$4n^2, logn, 3^n,20n,2,n^{2/3}$。又n!应该排在哪一位？2]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计课程复习]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[分治法设计递归函数，计算n!的值，其中n&gt;0。 1234int factorial(int n)&#123; if(n==1) return 1; else return factorial(n-1)*n;&#125; 算法总体思想 将求解的较大规模的问题分割成k个更小规模的子问题。对这k个子问题分别求解。 比如上面的factorial函数，将n规模的任务缩小为n-1规模的任务。任务规模不一定缩小为n-1，也可能是n/2（如：折半查找）等等。 如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解。 分治法的设计思想​ 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。凡治众如治寡，分数是也。—-孙子兵法 分治法的适用条件分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 这条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然也可用分治法，但一般用动态规划较好。 分治法的基本步骤(重要)divide-and-conquer(P){&nbsp;&nbsp;&nbsp;&nbsp;if ( | P | &lt;= n0) adhoc(P); //解决小规模的问题&nbsp;&nbsp;&nbsp;&nbsp;divide P into smaller subinstances P1,P2,…,Pk；//分解问题&nbsp;&nbsp;&nbsp;&nbsp;for (i=1,i&lt;=k,i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yi=divide-and-conquer(Pi); //递归的解各子问题&nbsp;&nbsp;&nbsp;&nbsp;return merge(y1,…,yk); //将各子问题的解合并为原问题的解} 分治法的复杂性分析(重要)一个分治法将规模为n的问题分成k个规模为n/m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： 通过迭代法求得方程的解（记住n^{\log_{m}k}，以后分析算法复杂度的时候会用到）： 二分搜索技术给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找出一特定元素x。 public static int binarySearch(int [] a, int x, int n){ // 在 a[0] &lt;= a[1] &lt;= … &lt;= a[n-1] 中搜索 x // 找到x时返回其在数组中的位置，否则返回-1 int left = 0; int right = n - 1; while (left &lt;= right) { int middle = (left + right)/2; if (x == a[middle]) return middle; if (x &gt; a[middle]) left = middle + 1; else right = middle - 1; } return -1; // 未找到x} 大整数的乘法 请设计一个有效的算法，可以进行两个n位大整数的乘法运算。 tip：算法分析，更多追求的是算法设计思想，别太深究代码中的错误。你如果硬要深究，我就说这是伪代码，哼(￢︿̫̿￢☆) X = a 2^{n/2}+bY = c 2^{n/2}+dXY = ac 2^n + (ad+bc) 2^{n/2} + bd XY = ac2^n + ((a-b)(d-c)+ac+bd)2^{n/2}+bd或 XY = ac 2^n + ((a+c)(b+d)-ac-bd) 2^{n/2} + bd 细节问题：两个XY的复杂度都是O(nlog3)，但考虑到a+c,b+d可能得到m+1位的结果，使问题的规模变大，故不选择第2种方案。 更快的方法??如果将大整数分成更多段，用更复杂的方式把它们组合起来，将有可能得到更优的算法。 最终的，这个思想导致了快速傅利叶变换(Fast Fourier Transform)的产生。该方法也可以看作是一个复杂的分治算法，对于大整数乘法，它能在O(nlogn)时间内解决。 是否能找到线性时间的算法？目前为止还没有结果。 Strassen矩阵乘法传统方法：O(n^3)分治法: 使用与上例类似的技术，将矩阵A，B和C中每一矩阵都分块成4个大小相等的子矩阵。由此可将方程C=AB重写为： \begin{bmatrix}C_{11} &C_{12} \\\\ C_{21} & C_{22} \end{bmatrix} = \begin{bmatrix}A_{11} &A_{12} \\\\ A_{21} & A_{22} \end{bmatrix}\begin{bmatrix}B_{11} &B_{12} \\\\ B_{21} & B_{22} \end{bmatrix}由此可得： C_{11}= A_{11}B_{11}+A_{12}B_{21}\\\\C_{12}=A_{11}B_{12}+A_{12}B_{22}\\\\C_{21}=A_{21}B_{11}+A_{22}B_{21}\\\\C_{22}=A_{21}B_{12}+A_{22}B_{22} 为了降低时间复杂度，必须减少乘法的次数。 更快的方法??Hopcroft和Kerr已经证明(1971)，计算2个２×２矩阵的乘积，7次乘法是必要的。因此，要想进一步改进矩阵乘法的时间复杂性，就不能再基于计算2×2矩阵的7次乘法的方法了。 或许应当研究３×３或５×５矩阵的更好算法。在Strassen之后又有许多算法改进了矩阵乘法的计算时间复杂性。目前最好的计算时间上界是 O(n^{2.376}) 是否能找到$O(n^2)$的算法？目前为止还没有结果。 思考题给定a，设计出求a^n的算法。 设计算法，找出数组a[n]的中位数。 设计算法，找出数组a[n]中序为k的数。 设计算法，输出数组a[n]中所有序为奇数的数。 设计算法，计算序列a[n]中的逆序数。 假设a[0:m]，a[m:n]均升序，设计算法，计算序列a[n]中的逆序数。 查找数组a[n]中的最大元素，至少需要多少次比较? 查找数组a[n]中的最大和最小元素，用最少的元素比较次数。 查找数组a[n]中的第k小的元素（k相对于n比较小)； 查找数组a[n]中的中位数（序号为n/2)； 参考汕头大学算法分析设计课程PPT__老师（CHYD） 补充人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种平衡(balancing)子问题的思想，它几乎总是比子问题规模不等的做法要好。 合并排序算法mergeSort的过程。 基本思想：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。 public static void mergeSort(Comparable a[], int left, int right){ if (left&lt;right) {//至少有2个元素 int i=(left+right)/2; //取中点 mergeSort(a, left, i); mergeSort(a, i+1, right); merge(a, b, left, i, right); //合并到数组b copy(a, b, left, right); //复制回数组a }} 复杂度分析： T(n) = \left \{ \begin{matrix} O(1) & n1\end{matrix} \right.T(n)=O(logn)渐进意义下的最优算法。 最坏时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)辅助空间：O(n)稳定性：稳定 快速排序快速排序是对气泡排序的一种改进方法。它是由C.A.R. Hoare于1962年提出的。 在快速排序中，记录的比较和交换是从两端向中间进行的，关键字较大的记录一次就能交换到后面单元，关键字较小的记录一次就能交换到前面单元，记录每次移动的距离较大，因而总的比较和移动次数较少。 private static void qSort(int p, int r){ if (p&lt;r) { int q=partition(p,r); //划分 qSort (p,q-1); //对左半段排序 qSort (q+1,r); //对右半段排序 }} private static int partition (int p, int r){ int i = p, j = r + 1; Comparable x = a[p]; // 将&gt;= x的元素交换到左边区域 // 将&lt;= x的元素交换到右边区域 while (true) { while (a[++i].compareTo(x) &lt; 0); while (a[—j].compareTo(x) &gt; 0); if (i &gt;= j) break; MyMath.swap(a, i, j); } a[p] = a[j]; a[j] = x; return j;} ​ 快速排序算法的性能取决于划分的对称性。通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。在快速排序算法的每一步中，当数组还没有被划分时，可以在a[p:r]中随机选出一个元素作为划分基准，这样可以使划分基准的选择是随机的，从而可以期望划分是较对称的。 private static int randomizedPartition (int p, int r){ int i = random(p,r); MyMath.swap(a, i, p); return partition (p, r);} 最坏时间复杂度：O(n2)平均时间复杂度：O(nlogn)辅助空间：O(n)或O(logn)稳定性：不稳定 思考题给定有序表A[1:n]，修改合并排序算法，求出该有序表的逆序对数。]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011---title: 模板date: 2019-06-14 21:01:24comments: truetoc: truecategories: - 云服务器tags: - centOS - tomcat--- 注意，使用latex公式时，要用两个$$符号，不是一个，不然在网页端解析会出现问题。 md文件中敲再多连续的空格，到了网页上都只会显示一个空格。于是就想着将md文件中的连续的四个空格替换为： 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 怎么实现呢？用nodejs 替换文件中所有图片的url 参考上面的文章。把它写好后，在hexo g开始后，马上替换掉md文件中符合要求的内容，这样就不用每次都选中，然后ctrl+h进行替换了。]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标点击特效]]></title>
    <url>%2F2019%2F06%2F14%2Fhouse%2F</url>
    <content type="text"><![CDATA[鼠标点击特效鼠标的点击红心特效如下： 具体步骤如下： 在/themes/next/source/js/src下新建文件 clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 文章结束标志 在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[picture]]></title>
    <url>%2F2019%2F06%2F14%2Fpicture%2F</url>
    <content type="text"><![CDATA[hexo 图片，插件： 写文章时图片路径： 生成文章时图片路径： 所以找不到图片啊！ 到这个仓库区， https://github.com/xcodebuild/hexo-asset-image.git 下载以后，还得改index.js。因为它的有错误！ 比如我发现这么个错误： 12// var endPos = link.lastIndexOf('.'); //获取最后一个点的位置，不就是.io吗？也说不定啊，文件名可以允许有点啊。比如saff.sfa.jpg，这里显得不严谨！所以后面切子串错了！var endPos = getPosition(link, '/', 7); 改完这个后，再在typora设置： 现在我可以在typora上可视化的插入图片进行编写md文件了。 不用写那么麻烦的官方标签了，比如： 1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 这样的标签在typora上无法渲染，在GitHub上也无法渲染。 文章基本设置： 12345678910---title: CentOS7下Tomcat启动慢的原因及解决方案date: 2017-12-02 21:01:24comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;云服务器&quot; #分类tags: #标签 - centOS - tomcat--- 参考： https://blog.csdn.net/xjm850552586/article/details/84101345]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[read_time]]></title>
    <url>%2F2019%2F06%2F14%2Fread-time%2F</url>
    <content type="text"><![CDATA[本文字数： undefined | 阅读时长 ≈ NaN:aN 这是为什么？]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test3]]></title>
    <url>%2F2019%2F06%2F14%2Ftest3%2F</url>
    <content type="text"><![CDATA[测试图片： 必须注意，在hexo b的时候，不是把所有文件上传一遍。 所以，如果远程的仓库更新了某个文件，而在本地没有更新，很可能这个文件会一直在本地得不到更新！你调试永远出错，你还奇了怪了。 这个时候，你只能回退版本了。 以本地仓库为主，别在远程更新文件！ svn回退文件，却不能恢复git记录文件的值，这点也很伤。所以别用svn回退文件了。就算要回退，也要复制粘贴！]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_test2]]></title>
    <url>%2F2019%2F06%2F13%2Fhexo-test2%2F</url>
    <content type="text"><![CDATA[hexo 标签 12345title: hexo_test2date: 2019-06-13 22:24:53tags: - hexo- 入门 sidebar侧边栏，打开 主题配置文件 找到sidebar字段 头像设置，打开 主题配置文件 找到Sidebar Avatar字段（侧边栏阿凡达……） 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： 12title: 分类测试文章标题categories: 分类名 把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 添加关于模块1、新建一个关于页面1$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释 添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看。 参考资料 Hexo的Next主题详细配置]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_hi_test]]></title>
    <url>%2F2019%2F06%2F13%2Fhexo-hi-test%2F</url>
    <content type="text"><![CDATA[测试Leancloud官网 创建一个应用：article_reading_statistics 这怎么还出现阿拉伯文了？ 把zh_cn改成zh-CN试试。可以了。 概述了解您的资源在效果、索引涵盖范围和增强选项成功率方面的总体情况。打开报告可深入了解相关信息。 覆盖率查看 Google 能/不能将您网站中的哪些网页编入索引以及相关原因。 站点地图查看 Google 在您的网站中找到的站点地图，然后提交新的站点地图。 在 Google 搜索结果中的表现探索您的资源在 Google 搜索中的效果，包括展示次数、排名、点击率和热门查询字符串。 已成功提交站点地图Google 会定期处理该站点地图，看看是否有任何更改。日后，如果该站点地图出现任何问题，我们会通知您。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
